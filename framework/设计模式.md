## JS实现设计模式



### 一、单例模式

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点

```javascript
var Singleton = function (name) {
  this.name = name 
  this.instance = null
}

Singleton.prototype.getName = function (){
  console.log(this.name)
}

Singleton.getInstance = function(name) {
  if (!this.instance) {
    this.instance = new Singleton(name)
  }
  
  return this.instance
}

// test
var a = Singleton.getInstance( 'sven1' )
var b = Singleton.getInstance( 'sven2' )
console.log( a === b ); // true
	
```



#### 用代理实现单例模式

```javascript
var Singleton = function (name) {
  this.name = name
  this.init()
}

Singleton.prototype.init = function(){
  // do sth ...
}

var ProxySingletonCreate = (function () {
  var instance
  return function (name) {
    if (!instance)
      instance = new Singleton(name)
    
    return instance
  }
})()

// test
var a = new ProxySingletonCreate( 'sven1' )
var b = new ProxySingletonCreate( 'sven2' )
console.log( a === b ); // true
```



#### JS实现单例模式

js中没有class，不太需要new，使用对象即可

使用**命名空间**或者**闭包封装**即可



#### 惰性单例

使用时才创建。栗子为唯一的弹出窗，用标志位判断是否创建过，创建过只让其显示，否之创建在显示

```html
<html>
  <body>
    <button id="loginBtn">
     	登录
    </button>
  </body>
</html>

<script>
	var createLoginLayer = (function () {
    var div
    return function () {
      if (!div) {
        div = document.createElement('div')
        div.innerHTML = '登录浮窗'
        div.style.display = 'none'
        document.body.appendChild(div)
      }
      
      return div
    } 
  })()
  
  document.getElementById('loginBtn').onClick = function() {
    var loginLayer = createLoginLayer()
    loginLayer.style.display = 'block'
  }
</script>
```



#### 通用惰性单例

上例惰性单例有一些问题，违反单一职责原则，创建对象和管理单例的逻辑都放在createLoginLayer对象内部。下次需要创建新的需要把createLoginLayer函数几乎照抄一遍

```javascript
var getSingle = function (fn) {
  var result
  return function () {
    return result || (result = fn.apply(this, arguments))
  }
}

var createLoginLayer = function () {
  var div = document.createElement('div')
  div.innerHTML = '登录浮窗'
  div.style.display = 'none'
  document.body.appendChild(div)
}

var createSingleLoginLayer = getSingle(createLoginLayer)

document.getElementById( 'loginBtn' ).onclick = function(){ 
  var loginLayer = createSingleLoginLayer()
  loginLayer.style.display = 'block'
}
```





### 二、策略模式

> 定义一系列算法，把它们封装起来使得可以相互替换
>
> 一个基于策略模式的程序至少由两部分组成，第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算步骤。第二个部分是环境类Context，用于接受客户的请求并委托给某一个策略类

模仿传统面向对象语言中的实现

```javascript
// 绩效计算
var performance_s = function () {}
performance_s.prototype.calculate = function (salary) {
  return salary * 4
}

var performance_a = function () {}
performance_a.prototype.calculate = function (salary) {
  return salary * 3
}

var performance_b = function () {}
performance_b.prototype.calculate = function (salary) {
  return salary * 2
}

// 奖金计算
var Bonus = function () {
  this.salary = null // 原始工资
  this.strategy = null // 绩效等级对应的策略对象
}

Bonus.prototype.setSalary = function (salary) {
  this.salary = salary
}

Bonus.prototype.setStrategy = function (strategy) {
  this.strategy = strategy
}

Bonus.prototype.getBonus = function () {
  return this.strategy.calculate(this.salary) // 把计算奖金的操作委托给对应的策略对象
}

// test
var bonus = new Bonus()
bonus.setSalary(10000)
bonus.setStrategy( new performance_s() ) // 设置策略对象

bonus.getBonus() // 获取输出 40000

bonus.setStrategy( new performance_b() ) // 设置策略对象
bonus.getBonus() // 获取输出 20000
```



#### JS实现策略模式

```javascript
var strategies = {
  s: function (salary) { return salary * 4 },
  a: function (salary) { return salary * 3 },
  b: function (salary) { return salary * 2 }
}

var calculateBonus = function (level, salary) {
  return strategies[level](salary)
}
```



#### 策略模式的优缺点

优点：

1. 策略模式利用了组合，委托，多态的思想，可以有效避免多重条件选择语句
2. 策略模式提供了对 开放-封闭 原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展
3. 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的ctrl + cv工作
4. 在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案

缺点：

1. 在程序中会增加很多策略类或策略对象
2. 要适用策略模式必须了解所有的strategy及其不同点



#### 一等函数对象与策略模式

在函数作为一等对象的语言中，策略模式是隐形的