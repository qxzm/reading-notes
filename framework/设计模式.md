## JS实现设计模式

> **设计模式六大原则**
>
> **单一职责原则**：就一个类（通常也包括对象和函数）而言，应该仅有一个引起它变化的原因。
>
> **里式替换原则**：所有引用父类的地方必须能透明的使用其子类的对象。即子类可以扩展父类的功能，但是不能修改原有父类的功能
>
> **依赖倒置原则**：抽象不应该依赖细节，细节应该依赖抽象。即要针对接口编程，而不是针对实现编程
>
> **接口隔离原则**：使用多个专门的接口，而不是使用单一的总接口。即客户端不应该依赖那些它不需要的接口
>
> **迪米特原则**：一个软件应该尽可能少的与其他实体发生相互作用
>
> **开闭原则**：一个软件应当对扩展开放，对修改关闭。即尽量在不修改原有代码的情况下进行扩展。



### 一、单例模式

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点

```javascript
var Singleton = function (name) {
  this.name = name 
  this.instance = null
}

Singleton.prototype.getName = function (){
  console.log(this.name)
}

Singleton.getInstance = function(name) {
  if (!this.instance) {
    this.instance = new Singleton(name)
  }
  
  return this.instance
}

// test
var a = Singleton.getInstance( 'sven1' )
var b = Singleton.getInstance( 'sven2' )
console.log( a === b ); // true
	
```



#### 用代理实现单例模式

```javascript
var Singleton = function (name) {
  this.name = name
  this.init()
}

Singleton.prototype.init = function(){
  // do sth ...
}

var ProxySingletonCreate = (function () {
  var instance
  return function (name) {
    if (!instance)
      instance = new Singleton(name)
    
    return instance
  }
})()

// test
var a = new ProxySingletonCreate( 'sven1' )
var b = new ProxySingletonCreate( 'sven2' )
console.log( a === b ); // true
```



#### JS实现单例模式

js中没有class，不太需要new，使用对象即可

使用**命名空间**或者**闭包封装**即可



#### 惰性单例

使用时才创建。栗子为唯一的弹出窗，用标志位判断是否创建过，创建过只让其显示，否之创建在显示

```html
<html>
  <body>
    <button id="loginBtn">
     	登录
    </button>
  </body>
</html>

<script>
	var createLoginLayer = (function () {
    var div
    return function () {
      if (!div) {
        div = document.createElement('div')
        div.innerHTML = '登录浮窗'
        div.style.display = 'none'
        document.body.appendChild(div)
      }
      
      return div
    } 
  })()
  
  document.getElementById('loginBtn').onClick = function() {
    var loginLayer = createLoginLayer()
    loginLayer.style.display = 'block'
  }
</script>
```



#### 通用惰性单例

上例惰性单例有一些问题，违反单一职责原则，创建对象和管理单例的逻辑都放在createLoginLayer对象内部。下次需要创建新的需要把createLoginLayer函数几乎照抄一遍

```javascript
var getSingle = function (fn) {
  var result
  return function () {
    return result || (result = fn.apply(this, arguments))
  }
}

var createLoginLayer = function () {
  var div = document.createElement('div')
  div.innerHTML = '登录浮窗'
  div.style.display = 'none'
  document.body.appendChild(div)
}

var createSingleLoginLayer = getSingle(createLoginLayer)

document.getElementById( 'loginBtn' ).onclick = function(){ 
  var loginLayer = createSingleLoginLayer()
  loginLayer.style.display = 'block'
}
```





### 二、策略模式

> 定义一系列算法，把它们封装起来使得可以相互替换
>
> 一个基于策略模式的程序至少由两部分组成，第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算步骤。第二个部分是环境类Context，用于接受客户的请求并委托给某一个策略类

模仿传统面向对象语言中的实现

```javascript
// 绩效计算
var performance_s = function () {}
performance_s.prototype.calculate = function (salary) {
  return salary * 4
}

var performance_a = function () {}
performance_a.prototype.calculate = function (salary) {
  return salary * 3
}

var performance_b = function () {}
performance_b.prototype.calculate = function (salary) {
  return salary * 2
}

// 奖金计算
var Bonus = function () {
  this.salary = null // 原始工资
  this.strategy = null // 绩效等级对应的策略对象
}

Bonus.prototype.setSalary = function (salary) {
  this.salary = salary
}

Bonus.prototype.setStrategy = function (strategy) {
  this.strategy = strategy
}

Bonus.prototype.getBonus = function () {
  return this.strategy.calculate(this.salary) // 把计算奖金的操作委托给对应的策略对象
}

// test
var bonus = new Bonus()
bonus.setSalary(10000)
bonus.setStrategy( new performance_s() ) // 设置策略对象

bonus.getBonus() // 获取输出 40000

bonus.setStrategy( new performance_b() ) // 设置策略对象
bonus.getBonus() // 获取输出 20000
```



#### JS实现策略模式

```javascript
var strategies = {
  s: function (salary) { return salary * 4 },
  a: function (salary) { return salary * 3 },
  b: function (salary) { return salary * 2 }
}

var calculateBonus = function (level, salary) {
  return strategies[level](salary)
}
```



#### 策略模式的优缺点

优点：

1. 策略模式利用了组合，委托，多态的思想，可以有效避免多重条件选择语句
2. 策略模式提供了对 开放-封闭 原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展
3. 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的ctrl + cv工作
4. 在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案

缺点：

1. 在程序中会增加很多策略类或策略对象
2. 要适用策略模式必须了解所有的strategy及其不同点



#### 一等函数对象与策略模式

在函数作为一等对象的语言中，策略模式是隐形的





### 三、代理模式

> 为一个对象提供一个代用品或者占位符，以便控制对它的访问

```javascript
// 小明送花
var Flower = function () {}

var xiaoming = {
  sendFlower: function (target) {
    var flower = new Flower()
    target.receiveFlower(flower)
  }
}

var godGirl = {
  receiveFlower: function (flower) {
    console.log('收到花 ' + flower)
  }
}

xiaoming.sendFlower(godGirl)

// 引入代理
var Flower = function () {}

var xiaoming = {
  sendFlower: function (target) {
    var flower = new Flower()
    target.receiveFlower(flower)
  }
}

var proxy = {
  receiveFlower: function (flower) {
    godGirl.receiveFlower(flower) // 普通代理
  }
}

var godGirl = {
  receiveFlower: function (flower) {
    console.log('收到花 ' + flower)
  }
}

xiaoming.sendFlower(proxy)


// 引入代理, 代理会做监听
var Flower = function () {}

var xiaoming = {
  sendFlower: function (target) {
    var flower = new Flower()
    target.receiveFlower(flower)
  }
}

var proxy = {
  receiveFlower: function (flower) {
    godGirl.listenGoodMood(function (flower) {
      godGirl.receiveFlower(flower)
    }) 
  }
}

var godGirl = {
  receiveFlower: function (flower) {
    console.log('收到花 ' + flower)
  },
  listenGoodMood: function (fn) {
    // 假设10秒后心情变好
    setTimeout(function(){
      fn()
    }, 10 * 1000)
  }
}

xiaoming.sendFlower(proxy)
```



#### 保护代理和虚拟代理

* 代理proxy可以帮助godGirl过滤掉一些请求，这种叫做**保护代理**
* new Flower操作很昂贵，将new Flower的操作交由proxy处理，代理proxy会在godGirl心情好的时候执行new操作，这种代理叫做**虚拟代理**

  ```javascript
  var proxy = {
    receiveFlower: function (flower) {
      godGirl.listenGoodMood(function () {
        var flower = new Flower()

        godGirl.receiveFlower(flower)
      })
    }
  }
  ```

js不容易实现保护代理，因为我们无法推断谁访问了对象，虚拟代理比较常用



#### 虚拟代理实现图片预加载

```javascript
var myImage = (function () {
  var imgNode = document.createElement('img')
  document.body.appendChild(imgNode)
  
  return {
    setSrc: function (src) {
      imgNode.src = src
    }
  }
})()

var proxyImage = (function () {
  var img = new Image()
  img.onload = function () {
    myImage.setSrc(this.src) // this is img
  }
  
  return {
    setSrc: function (src) {
      myImage.setSrc('../loading.png')
      img.src = src
    }
  }
})()

proxyImage.setSrc('../real_image.png')
```



#### 虚拟代理在惰性加载中的应用

```js
// miniConsole 在 f12点击后才加载

// 添加占位符
var cache
var miniConsole = {
  log: function () {
    var args = arguments
    cache.push(function () {
      // 此处使用加载过后的miniConsole替代占位符
      return miniConsole.log.apply(miniConsole, args)
    })
  }
}

// 用户使用 无感知
miniConsole.log(1)

// 点击f12
var handler = function (event) {
  if (event.keyCode === 113) {
    var script = document.createElement('script')
    script.onload = function () {
      for (var i = 0, fn; fn = cache[i++]; ) {
        fn() // 此处是替换真实的miniConsole
      }
    }
    
    script.src = 'miniConsole.js'
    document.getElementsByTagName('head')[0].appendChild(script)
    document.body.removeEventListener('keydown', handler) // 只加载一次 miniConsole.js
  }
}

document.body.addEventListener('keydown', handler, false)

// miniConsole.js
miniConsole = {
  log: function () {
    // 真正的代码
    console.log(Array.prototype.join.call(arguments))
  }
}
```



#### 缓存代理

为一些开销大的运算结果提供暂时的存储



### 四、迭代器模式

> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示



#### 实现自己的迭代器

```js
var each = function (ary, callback) {
  for (var i = 0, len = ary.length; i < len; i++) {
    callback.call(ary[i], i, ary[i])
  }
}

// test
each([1,2,3], function (i, n) {
  console.log([i, n])
})
```



#### 内部迭代器

> 函数内部定义好了规则，完全接受了整个迭代过程，外部只需要一次初始调用

```js
// 栗子如上实现的each
// 若要实现一个两个数组对比是否相等的compare函数
var compare = function (ary1, ary2) {
  if (ary1.length !== ary2.length)
    throw new Error('ary1 和 ary2 不相等')
  
  each(ary1, function (i, n) {
    if (n !== ary2[i])
      throw new Error('ary1 和 ary2 不相等')
  })
  
  console.log('ary1 和 ary2 相等')
}

// test
compare( [ 1, 2, 3 ], [ 1, 2, 4 ] ); // throw new Error ( 'ary1和ary2不相等' );
```



#### 外部迭代器

> 外部迭代器必须显示的请求迭代下一个元素

```js
var Iterator = function (obj) {
  var current = 0
  
  var next = function () {
    current += 1
  }
  
  var isDone = function () {
    return current >= obj.length
  }
  
  var getCurrItem = function () {
    return obj[current]
  }
  
  return {
    next: next,
    isDone: isDone,
    getCurrItem: getCurrItem
  }
}

// 重写compare
var compare = function (iterator1, iterator2) {
  while (!iterator1.isDone() && !iterator2.isDone()) {
    if (iterator1.getCurrItem() !== iterator2.getCurrItem()) {
      throw new Error('ary1 和 ary2 不相等')
    } else {
     	 iterator1.next()
       iterator2.next()
    }
  }
  
  console.log('ary1 和 ary2 相等')
}


// test
var iterator1 = Iterator( [ 1, 2, 3 ] );
var iterator2 = Iterator( [ 1, 2, 3 ] );
compare( iterator1, iterator2 ); // 输出:iterator1 和 iterator2 相等
```



#### 迭代器模式的应用

```js
// 根据不同浏览器获取对应的上传组件，原版很多if else，用迭代器改写
// 上传组件, 不存在返回false
var getActiveUploadObj = function () {
  try {
    return new ActiveXObject('TXFTNActiveX.FTNUpload') // IE
  } catch (e) {
    return false
  }
}

var getFlashUploadObj = function () {
  // supportFlash 函数未提供
  if (suppertFlash()) {
    var str = '<object type="application/x-shockwave-flash"></object>'
  	return $( str ).appendTo($('body'))
  }
  return false
}

var getFormUploadObj = function () {
  var str = '<input name="file" />' // 表单
  return $(str).appendTo($('body'))
}

// 迭代器
var iteratorUploadObj = function () {
  for (var i = 0, fn; fn = arguments[i++]; ) {
    var uploadObj = fn()
    
    if (uploadObj) {
     	return uploadObj
    }
  }
}


// test
var uploadObj = iteratorUploadObj( getActiveUploadObj,getFlashUploadObj,getFormUpladObj)

// 扩展
var getWebkitUploadObj = function(){}
var getHtml5UploadObj = function(){}
var uploadObj = iteratorUploadObj( getActiveUploadObj,getWebkitUploadObj,getFlashUploadObj, getHtml5UploadObj, getFormUpladObj )
```

