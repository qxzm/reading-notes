## 查找

#### 一、术语

* **查找表** (Search Tab) 是由同一类型的数据元素（或记录）构成的集合
* **关键字** (Key) 是数据元素中某个数据项的值 ，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项(字段) ，我们称为关键码。
* 若关键字可以唯一地标识一个记录，则称此关键字为**主关键字** （Primary Key）
* 对于那些可以识别 多个数据元素(或记录)的关键字，我们称为**次关键字**（Secon也ryKey）
* **查找**( Searchìng )就是根据给定的某个值 ， 在查找表中确定一个其关键字等于给定值的数据元素(或记录)。
* 查找表按照操作方式来分有两大种：
  * **静态查找表**(Static Search Table) :只作查找操作的查找表
  * **动态查找表** (Dynamic Search Table): 在查找过程中同时插入查找表中不存在的数据元素 ， 或者从查找表中删除已经存在的某个数据元素



#### 二、顺序表查找 Sequential Search

> 对于任意一个序列以及一个给定的元素，将给定元素与序列中元素依次比较，直到找出与给定关键字相同的元素，或者将序列中的元素与其都比较完为止。
>
> 每个元素都需要查找一遍，时间复杂度为O(n)

```javascript
// array为数组， n为要查找的数组个数. key为要查找的关键字
function SequentialSearc (array, n, key) {
  for(let i = 0; i <= n; i++) {
    if (array[i] === key) return i
  }
  
  return 0
}
```



#### 三、有序表查找

##### 1. 二分查找(折半查找) Binary Search

> 假定表中元素有序（如：升序），将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功。否则利用中间位置将表分为前后两个字表，中间位置的记录大于关键字，则查找前子表，否则查找后子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时不成功。
>
> 时间复杂度为O(㏒n)

```javascript
// array为数组， n为要查找的数组个数. key为要查找的关键字
function BinarySearch (array, n, key) {
	let low = 1 // 最低下标本例从1开始
  let high = n
  let mid
  
  while (low <= high) {
    mid = Math.floor((low + high) / 2)
    if (key < array[mid]) {
      high = mid - 1
    } else if (key > array[mid]) {
      low = mid + 1
    } else 
      return mid
  }
  
  return 0
}

let array = [0,1,16,24,35,47,59,62,73,88,99]
BinarySearch(array, 10, 62)
```



##### 2. 插值查找 Interpolation Search

> 根据要查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的计算公式
> $$
> 12/121
> $$
> **key-array[low] / array[high]-array[low]**
>
> 二分查找的代码 line 8 中 ```mid = Math.floor((low + high) / 2)``` 转换后就是```mid = Math.floor(low + 1/2(high - low))```，将其换成插值，对于表长较大而关键字分布相对均匀的表来说，平均性能高于二分查找



##### 3. 斐波那契查找 Fibonacci Search

> 

```javascript
// array为数组， n为要查找的数组个数. key为要查找的关键字
function FibonacciSearch (array, n, key) {
  let F = [0,1,1,2,3,5,8,13,21,34,55,89] // 斐波那契数列...
  let low = 1
  let high = n
  let mid
  
  let k = 0
  while (n > F[k] - 1) {
    k++
  }
  
  for (let i = n; i< F[k] - 1; i++) {
    array[i] = array[n]
  }
  
  while (low <= high) {
    mid = low + F[k-1] - 1
    
    if (key < array[mid]) {
      high = mid - 1
      k = k -1
    } else if (key > array[mid]) {
      low = mid + 1
      k = k - 2
    } else {
      if (mid <= n) return mid
      else return n
    }
  }
  
  return 0
}
```

